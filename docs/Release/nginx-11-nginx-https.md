---
group:
  title: Nginx
order: 11
title: nginx和https

nav:
  title: 发布部署
  order: 6
---

## 1、HTTP介绍
HTTP（HyperText Transfer Protocol，超文本传输协议）是互联网上应用最广泛的网络协议之一，用于客户端（如浏览器）与服务器之间传输超文本（如HTML页面）和其他资源。它是万维网（World Wide Web）数据通信的基础。

**基本概念：**

+ 作用：定义客户端如何向服务器请求资源，以及服务器如何响应这些请求。
+ 无状态性：HTTP 是无状态协议，即每次请求/响应都是独立的，服务器不会记住之前的交互（但可通过 Cookie、Session 等机制实现“有状态”行为）。
+ 基于请求-响应模型：客户端发起请求 → 服务器返回响应。
+ 应用层协议：位于 OSI 模型的应用层，通常运行在TCP（传输控制协议）之上，默认端口为 80（HTTPS 为 443）。

**为什么说HTTP不安全：**

说 HTTP 不安全，主要是因为它在设计之初没有内置任何加密或身份验证机制，所有数据都以明文（plaintext）形式在网络中传输。这带来了多个严重的安全隐患。下面从多个角度详细解释为什么 HTTP 被认为是“不安全”的：

**①、数据以明文传输（无加密）**

问题：HTTP 传输的所有内容（包括请求头、请求体、响应头、响应体）都是可读的纯文本。

后果：

攻击者可以通过网络嗅探（Sniffing）工具（如 Wireshark）轻松截获用户与服务器之间的通信。敏感信息（如用户名、密码、银行卡号、Cookie、聊天内容等）会被直接暴露。

如在咖啡店用 HTTP 登录一个网站，输入了账号密码：

```http
POST /login HTTP/1.1
...
username=alice&password=123456
```

同一Wi-Fi下的攻击者只需监听网络流量，就能看到对应的密码。

**②、容易遭受中间人攻击**

什么是MITM？

攻击者插入到客户端和服务器之间，可以窃听、篡改、伪造通信内容。

HTTP 的脆弱性：

+ 客户端无法验证它连接的是否是真正的服务器。
+ 攻击者可以伪装成目标网站（例如通过DNS劫持、ARP欺骗），返回恶意页面（如钓鱼网站）。
+ 甚至可以在网页中注入广告、恶意脚本（如挖矿代码、XSS攻击）。

**③、无法保证数据完整性**

HTTP传输过程中，数据可能被第三方篡改，而客户端无法察觉。

例如：

+ ISP（网络服务提供商）可能在网页中插入广告。
+ 公共 Wi-Fi 热点运营商可能修改网页内容。
+ 恶意代理服务器替换下载的软件为带病毒的版本。

对比HTTPS：

HTTPS 使用TLS协议，会对数据进行数字签名，一旦被篡改，接收方会立即发现并断开连接。

**④、无法验证服务器身份**

+ HTTP 协议本身不提供服务器身份验证机制。
+ 用户无法确认当前连接的服务器是否真的是www.example.com，还是冒充的钓鱼网站。
+ 这使得钓鱼攻击变得非常容易。

对比HTTPS：

通过数字证书（由CA颁发）验证服务器身份，浏览器会显示锁形图标，并阻止访问证书无效的网站。

**⑤、Cookie和会话劫持风险高**

在HTTP中，Cookie（尤其是包含Session ID的Cookie）以明文传输。攻击者一旦截获Cookie，就可以冒充用户身份（Session Hijacking），无需知道密码即可登录账户。

**举例使用charles验证HTTP安全性：**

实验1：直接抓包HTTPS —— 看不到明文

在浏览器中访问我们的服务器，并且进行提交表单操作，查看Charles中的请求，无法查看到URL路径、请求头、响应内容，所有数据都是TLS加密后的二进制流，无法解读。而直接抓包HTTP，则能看到明文。

实验2：尝试用Charles解密HTTPS

这一步模拟“如果安装了恶意根证书，HTTPS 也会被破解”——但正常用户不会这么做。

1. 在Charles中启用SSL代理：
    1. 菜单栏 → Proxy → SSL Proxying Settings。
    2. 勾选 Enable SSL Proxying。
    3. 添加 Location：* 和端口 443（表示拦截所有 HTTPS）。
2. 安装 Charles 根证书：
    1. 菜单栏 → Help → SSL Proxying → Install Charles Root Certificate。
    2. 按系统提示安装并设为“始终信任”（macOS 需在钥匙串中手动设置）。
    3. 再次访问表单并提交数据。

这不是HTTPS被攻破，而是本次操作主动信任了Charles作为中间人。普通用户不会安装未知CA证书，所以攻击者无法轻易做到这一点。浏览器和操作系统会严格校验证书链，非法证书会被拦截。HTTPS的安全性依赖于证书信任体系。只要用户不乱装根证书，中间人无法解密。

## 2、传输协议知识补充
### 2.1、HTTP和HTTPS的区别
HTTP是一种超文本传输协议(Hypertext Transfer Protocol)，HTTP是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范。

HTTP主要内容分为三部分，超文本（Hypertext）、传输（Transfer）、协议（Protocol）。

+ 超文本就是不单单只是本文，它还可以传输图片、音频、视频，甚至点击文字或图片能够进行超链接的跳转。
+ 上面这些概念可以统称为数据，传输就是数据需要经过一系列的物理介质从一个端系统传送到另外一个端系统的过程。通常我们把传输数据包的一方称为请求方，把接到二进制数据包的一方称为应答方。
+ 而协议指的就是是网络中(包括互联网)传递、管理信息的一些规范。如同人与人之间相互交流是需要遵循一定的规矩一样，计算机之间的相互通信需要共同遵守一定的规则，这些规则就称为协议，只不过是网络协议。

说到HTTP，不得不提的就是TCP/IP网络模型，一般是五层模型。如下图所示：

<!-- 这是一张图片，ocr 内容为： -->
![](../images//nginx/nginx202602101045.png)

而HTTPS的全称是Hypertext Transfer Protocol Secure，从名称我们可以看出HTTPS要比HTTPS多了 secure安全性这个概念，实际上， HTTPS 并不是一个新的应用层协议，它其实就是 HTTP + TLS/SSL 协议组合而成，而安全性的保证正是 TLS/SSL 所做的工作。

也就是说，HTTPS就是身披了一层SSL的HTTP。<!-- 这是一张图片，ocr 内容为： -->
![](../images//nginx/nginx202602101046.png)

**HTTP协议栈：**

```plain
┌─────────────────────────────────────┐
│         HTTP 应用层协议               │ ← 明文数据传输
├─────────────────────────────────────┤
│        TCP传输层协议                │
├─────────────────────────────────────┤
│         IP 网络层协议                 │
└─────────────────────────────────────┘
```

**HTTPS协议栈：**

```plain
┌─────────────────────────────────────┐
│         HTTP 应用层协议               │ ← 加密数据传输
├─────────────────────────────────────┤
│    SSL/TLS 安全套接层                 │ ← 安全层
├─────────────────────────────────────┤
│        TCP传输层协议                │
├─────────────────────────────────────┤
│         IP 网络层协议                 │
└─────────────────────────────────────┘
```

下面将从多个角度详细介绍它们的区别。

**1.基本定义**

+ HTTP（超文本传输协议）：一种用于传输超媒体文档（如HTML）的应用层协议。它是万维网数据通信的基础，设计用于在Web浏览器和Web服务器之间传输信息。
+ HTTPS（超文本传输安全协议）：HTTP的安全版本，通过在HTTP下加入SSL/TLS协议来对传输的数据进行加密，从而提供对网站服务器的身份认证和保护交换数据的隐私与完整性。

**2. 安全性**

+ HTTP：数据以明文传输，不提供任何方式的数据加密。这意味着在传输过程中，数据可以被中间人（如黑客、ISP、政府机构）窃听、篡改或冒充。
+ HTTPS：使用SSL/TLS协议对传输的数据进行加密。这确保了数据在传输过程中的机密性（加密）、完整性（防篡改）和身份认证（验证服务器身份）。

**3. 默认端口**

+ HTTP：默认使用端口80。
+ HTTPS：默认使用端口443。

**4. 协议栈**

+ HTTP：直接位于TCP协议之上。
+ HTTPS：在HTTP和TCP之间加入了一个安全层（SSL/TLS）。因此，HTTPS可以看作是HTTP over SSL/TLS。

**5. 证书与身份认证**

+ HTTP：不需要证书，无法验证服务器的真实身份。
+ HTTPS：需要由可信任的证书颁发机构（CA）颁发的SSL证书。当用户访问HTTPS网站时，浏览器会验证证书的有效性，从而确认网站的真实性，防止中间人攻击。

**6. 性能**

+ HTTP：由于没有加密和解密的过程，传输速度相对较快。
+ HTTPS：由于加密和解密需要计算资源，会增加一些延迟，降低传输速度。但随着硬件性能的提升和协议的优化（如TLS 1.3），这种差异已经越来越小。

**7. SEO（搜索引擎优化）**

+ 搜索引擎（如Google）已经将HTTPS作为排名信号。使用HTTPS的网站在搜索结果中可能会有更高的排名。

**8. 浏览器显示**

+ 现代浏览器对HTTPS网站会显示一个锁形图标，表示连接是安全的。而HTTP网站则标记为“不安全”。

**9. 使用场景**

+ HTTP：适用于不涉及敏感信息传输的场景，如新闻网站、博客等。
+ HTTPS：适用于所有需要保护用户隐私和数据完整性的场景，如电子商务、在线银行、登录页面、任何涉及个人数据的传输。

**10. 建立连接的过程**

+ HTTP：直接通过TCP三次握手建立连接，然后传输数据。
+ HTTPS：在TCP三次握手之后，还需要进行SSL/TLS握手，以建立安全连接。这个过程包括协商加密算法、验证证书、生成会话密钥等步骤。

**11. 数据完整性**

+ HTTP：不提供数据完整性保护，数据在传输过程中可能被篡改而无法察觉。
+ HTTPS：通过消息认证码（MAC）来保证数据完整性，任何篡改都会被检测到。

**12. 对网络设备的要求**

+ HTTP：网络设备（如代理、防火墙）可以解析和修改HTTP流量。
+ HTTPS：由于数据被加密，网络设备无法解析内容，只能看到加密的数据流。这提供了隐私保护，但也使得一些网络管理功能（如内容过滤）更复杂。

### 2.2、TCP的三次握手和四次挥手
TCP的全称是Transmission Control Protocol ，传输控制协议。它能够帮助你确定计算机连接到 Internet 以及它们之间的数据传输。通过三次握手来建立TCP连接，三次握手就是用来启动和确认TCP连接的过程。一旦连接建立后，就可以发送数据了，当数据传输完成后，会通过关闭虚拟电路来断开连接。

**TCP的主要特点有：**

+ TCP能够确保连接的建立和数据包的发送。
+ TCP支持错误重传机制。
+ TCP支持拥塞控制，能够在网络拥堵的情况下延迟发送。
+ TCP能够提供错误校验和，甄别有害的数据包。

TCP三次握手和四次挥手也是面试题的热门考点，它们分别对应TCP的连接和释放过程。下面就来简单认识一下这两个过程。

#### 2.2.1、TCP三次握手
在了解具体的流程前，我们需要先认识几个概念：

| 消息类型 | 描述 |
| --- | --- |
| SYN | 这个消息是用来初始化和建立连接的。 |
| ACK | 帮助对方确认收到的 SYN 消息 |
| SYN-ACK | 本地的 SYN 消息和较早的 ACK 数据包 |
| FIN | 用来断开连接 |


+ SYN：它的全称是 Synchronize Sequence Numbers，同步序列编号。是TCP/IP建立连接时使用的握手信号。在客户机和服务器之间建立TCP连接时，首先会发送的一个信号。客户端在接受到SYN消息时，就会在自己的段内生成一个随机值X。
+ SYN-ACK：服务器收到SYN后，打开客户端连接，发送一个 SYN-ACK 作为答复。确认号设置为比接收到的序列号多一个，即 X + 1，服务器为数据包选择的序列号是另一个随机数 Y。
+ ACK：Acknowledge character, 确认字符，表示发来的数据已确认接收无误。最后，客户端将 ACK 发送给服务器。序列号被设置为所接收的确认值即 Y + 1。  
<!-- 这是一张图片，ocr 内容为： -->
![](../images//nginx/nginx202602101047.png)

如果用现实生活来举例的话就是：

小明 - 客户端 小红 - 服务端

+ 小明给小红打电话，接通了后，小明说喂，能听到吗，这就相当于是连接建立。
+ 小红给小明回应，能听到，你能听到我说的话吗，这就相当于是请求响应。
+ 小明听到小红的回应后，好的，这相当于是连接确认。在这之后小明和小红就可以通话/交换信息了。

#### 2.2.2、TCP四次挥手
在连接终止阶段使用四次挥手，连接的每一端都会独立的终止。下面我们来描述一下这个过程。<!-- 这是一张图片，ocr 内容为： -->
![](../images//nginx/nginx202602101048.png)

+ 首先，客户端应用程序决定要终止连接(这里服务端也可以选择断开连接)。这会使客户端将 FIN 发送到服务器，并进入 FIN_WAIT_1 状态。当客户端处于 FIN_WAIT_1 状态时，它会等待来自服务器的 ACK 响应。
+ 然后第二步，当服务器收到 FIN 消息时，服务器会立刻向客户端发送 ACK 确认消息。
+ 当客户端收到服务器发送的 ACK 响应后，客户端就进入 FIN_WAIT_2 状态，然后等待来自服务器的 FIN 消息
+ 服务器发送 ACK 确认消息后，一段时间（可以进行关闭后）会发送 FIN 消息给客户端，告知客户端可以进行关闭。
+ 当客户端收到从服务端发送的 FIN 消息时，客户端就会由 FIN_WAIT_2 状态变为 TIME_WAIT 状态。处于 TIME_WAIT 状态的客户端允许重新发送 ACK 到服务器为了防止信息丢失。客户端在 TIME_WAIT 状态下花费的时间取决于它的实现，在等待一段时间后，连接关闭，客户端上所有的资源（包括端口号和缓冲区数据）都被释放。

还是可以用上面那个通话的例子来进行描述：

+ 小明对小红说，我所有的东西都说完了，我要挂电话了。
+ 小红说，收到，我这边还有一些东西没说。
+ 经过若干秒后，小红也说完了，小红说，我说完了，现在可以挂断了
+ 小明收到消息后，又等了若干时间后，挂断了电话。

### 2.3、SSL/TLS协议详解
SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）是用于在网络通信中提供安全性和数据完整性的加密协议。SSL 最初由 Netscape 公司在 1990 年代开发，后来被 IETF（互联网工程任务组）标准化并演进为 TLS。目前广泛使用的是 TLS 1.2 和 TLS 1.3，而 SSL 已被弃用（存在严重安全漏洞，如 POODLE 攻击）。

**TLS 的主要目标包括：**

+ 机密性（Confidentiality）：防止第三方窃听通信内容。
+ 完整性（Integrity）：确保数据在传输过程中未被篡改。
+ 身份认证（Authentication）：验证通信双方的身份（通常服务器必须认证，客户端可选）。
+ 前向保密（Forward Secrecy）：即使长期私钥泄露，过去的会话也无法被解密（现代 TLS 支持）。

TLS 协议位于应用层（如 HTTP）和传输层（如 TCP）之间，可分为两层：

+ TLS 记录协议（Record Protocol）：负责对上层数据进行分片、压缩（已废弃）、加密、添加 MAC（消息认证码），并封装成记录单元进行传输。
+ TLS 握手协议（Handshake Protocol）：用于协商加密参数、交换密钥、认证身份等。还包括：
    - Change Cipher Spec 协议。
    - Alert 协议（用于报告错误）。
    - Application Data 协议（承载加密后的应用数据）。

典型的 TLS 握手包含以下步骤（简化版）：

1. ClientHello：客户端发送支持的 TLS 版本、随机数（Client Random）、支持的密码套件（Cipher Suites）、压缩方法等。
2. ServerHello：服务器选择一个 TLS 版本、生成自己的随机数（Server Random）、从客户端提供的密码套件中选择一个，并返回选定的参数。
3. Server Certificate：服务器发送其数字证书（包含公钥），用于身份认证。证书由受信任的 CA（证书颁发机构）签发。
4. ServerKeyExchange（可选）：如果所选密码套件需要额外的密钥交换信息（如使用 DHE 或 ECDHE），服务器在此发送其公钥参数。
5. ServerHelloDone：表示服务器握手消息结束。
6. ClientKeyExchange：客户端生成预主密钥（Pre-Master Secret），并用服务器公钥加密后发送（若使用 RSA 密钥交换）；或发送自己的 DH/ECDH 公钥（若使用 Diffie-Hellman 类密钥交换）。
7. 密钥派生：双方使用 Client Random、Server Random 和 Pre-Master Secret，通过伪随机函数（PRF）生成主密钥（Master Secret），再派生出用于加密和 MAC 的会话密钥（对称密钥）。
8. ChangeCipherSpec：双方通知对方：后续通信将使用刚刚协商好的加密参数。
9. Finished：双方发送加密的 Finished 消息，包含之前所有握手消息的摘要，用于验证握手完整性。

至此，安全通道建立完成，应用层数据（如 HTTPS 请求）开始通过 TLS 记录协议加密传输。

TLS 旨在为 Internet 提供通信安全的加密协议。TLS 握手是启动和使用 TLS 加密的通信会话的过程。在 TLS 握手期间，Internet 中的通信双方会彼此交换信息，验证密码套件，交换会话密钥。每当用户通过 HTTPS 导航到具体的网站并发送请求时，就会进行 TLS 握手。除此之外，每当其他任何通信使用HTTPS（包括 API 调用和在 HTTPS 上查询 DNS）时，也会发生 TLS 握手。

TLS 具体的握手过程会根据所使用的密钥交换算法的类型和双方支持的密码套件而不同。 我们以RSA 非对称加密来讨论这个过程。整个 TLS 通信流程图如下：

<!-- 这是一张图片，ocr 内容为： -->
![](../images//nginx/nginx202602101049.png)

在进行通信前，首先会进行 HTTP 的三次握手，握手完成后，再进行 TLS 的握手过程。

+ ClientHello：客户端通过向服务器发送 hello 消息来发起握手过程。这个消息中会夹带着客户端支持的 TLS 版本号(TLS1.0 、TLS1.2、TLS1.3) 、客户端支持的密码套件、以及一串 客户端随机数。
+ ServerHello：在客户端发送 hello 消息后，服务器会发送一条消息，这条消息包含了服务器的 SSL 证书、服务器选择的密码套件和服务器生成的随机数。
+ 认证(Authentication)：客户端的证书颁发机构会认证 SSL 证书，然后发送 Certificate 报文，报文中包含公开密钥证书。最后服务器发送 ServerHelloDone 作为 hello 请求的响应。第一部分握手阶段结束。
+ 加密阶段：在第一个阶段握手完成后，客户端会发送 ClientKeyExchange 作为响应，这个响应中包含了一种称为 The premaster secret 的密钥字符串，这个字符串就是使用上面公开密钥证书进行加密的字符串。随后客户端会发送 ChangeCipherSpec，告诉服务端使用私钥解密这个 premaster secret 的字符串，然后客户端发送 Finished 告诉服务端自己发送完成了。

### 2.4、加密原理
TLS 结合了多种密码学技术，属于“混合加密系统”：

+ **非对称加密**：用于密钥交换和身份认证。常见算法：
    - RSA：用于加密预主密钥或签名。
    - (EC)DHE（Elliptic Curve Diffie-Hellman Ephemeral）：实现前向保密的密钥协商。
    - 非对称加密计算开销大，仅用于握手阶段。
+ **对称加密**：握手完成后，使用对称密钥加密实际数据，效率高。常见算法：
    - AES（Advanced Encryption Standard）：最常用，支持 128/256 位密钥。
    - ChaCha20：Google 推广的流加密算法，适用于移动设备。
    - 加密模式如 GCM（Galois/Counter Mode）同时提供加密和完整性校验。
+ **消息认证码（MAC）与完整性保护**：早期 TLS 使用 HMAC（基于哈希的消息认证码）配合 CBC 模式；现代 TLS（如 AES-GCM、ChaCha20-Poly1305）使用 AEAD（Authenticated Encryption with Associated Data）模式，同时实现加密和认证。
+ **数字证书与 PKI（公钥基础设施）**：服务器证书包含其公钥和身份信息，由 CA 签名。客户端通过信任的根证书验证服务器证书链，防止中间人攻击。
+ **前向保密**：使用临时（Ephemeral）Diffie-Hellman 密钥交换（如 DHE、ECDHE），每次会话生成新的密钥对。即使服务器私钥日后泄露，也无法解密历史会话。

#### 2.4.1、非对称加密
非对称加密是一种使用两个不同但数学相关的密钥进行加密和解密的密码技术：

+ 公钥（Public Key）：可以公开给任何人，用于加密数据。
+ 私钥（Private Key）：必须严格保密，只有拥有者知道，用于解密数据。

用公钥加密的数据，只能用对应的私钥解密；反之亦然（在某些场景下）。因为加密和解密用的不是同一个密钥（不像对称加密，比如 AES，加解密都用同一把钥匙），所以叫“非对称”。

非对称加密的两个主要用途：

+ 加密通信（保密性）
    - 别人用你的公钥加密消息 → 只有你能用私钥解密。
    - 应用：HTTPS 中安全传输“会话密钥”（虽然现代多用 ECDHE，但原理相关）。
+ 数字签名（身份认证 + 完整性）
    - 你用私钥对一段信息生成“签名”。
    - 别人用你的公钥验证这个签名是否真实。
    - 如果能验证成功，说明：
        * 信息确实是你发的（身份认证）。
        * 信息在传输中没被篡改（完整性）。

**注意：签名 ≠ 加密！**

签名是用私钥“盖章”，不是隐藏内容；加密是用公钥“上锁”，是为了隐藏内容。

**常见的非对称加密算法：**

| 算法 | 用途 | 特点 |
| --- | --- | --- |
| RSA | 加密、签名 | 最经典，基于大数分解难题 |
| ECC（椭圆曲线加密） | 加密、签名 | 安全性高，密钥短（如 256 位 ECC ≈ 3072 位 RSA） |
| ECDH / ECDHE | 密钥交换 | 用于 HTTPS 前向保密 |
| EdDSA | 签名 | 快速安全，常用于 SSH、区块链 |


**非对称加密的缺点:**

+ 速度慢：比对称加密（如 AES）慢几百到上千倍。
+ 不适合加密大量数据：通常只用于加密“密钥”或做“签名”。

所以实际应用中（如 HTTPS、SSH），都是混合使用：

+ 用非对称加密安全地交换一个对称密钥。
+ 之后用对称加密高效传输大量数据。

现实中的应用场景：

| 场景 | 如何使用非对称加密 |
| --- | --- |
| HTTPS 网站 | 服务器用证书提供公钥，浏览器验证身份并协商密钥 |
| SSH 登录 | 用公钥认证用户身份（免密码登录） |
| 数字证书 | CA 用私钥签名网站证书，浏览器用 CA 公钥验证 |
| 比特币/区块链 | 用私钥签名交易，公钥作为收款地址 |
| PGP 加密邮件 | 用对方公钥加密邮件，只有对方能解密 |


#### 2.4.2、对称加密
对称加密是一种加密方式：加密和解密使用的是同一把密钥。

+ 发送方用 密钥 K 把明文（原始数据）加密成密文；
+ 接收方用 同样的密钥 K 把密文解密回明文。

因为“加”和“解”用的是对称的同一把钥匙，所以叫“对称加密”。

**核心三要素：**

+ 明文（Plaintext）：原始可读的数据（比如 "Hello"）。
+ 密钥（Key）：一个秘密的字符串或数字（比如 "mysecretkey123"）。
+ 密文（Ciphertext）：加密后不可读的乱码（比如 "X5#9!qLm@"）。

**常见的对称加密算法：**

| 算法 | 密钥长度 | 特点 |
| --- | --- | --- |
| AES（Advanced Encryption Standard） | 128 / 192 / 256 位 | ✅ 最主流！安全、高效，被全球广泛使用（如 HTTPS、Wi-Fi、磁盘加密） |
| ChaCha20 | 256 位 | ✅ 在移动设备和低功耗设备上比 AES 更快，Google 大力推广 |
| DES | 56 位 | ❌ 已过时，不安全（密钥太短） |
| 3DES | 112/168 位 | ⚠️ 比 DES 安全，但慢，逐渐被淘汰 |


**对称加密的优点：**

+ 速度快：比非对称加密快几十到上千倍。
+ 适合大数据量：可用于加密文件、视频、网络流量等。
+ 硬件支持好：现代 CPU 有 AES 指令集加速。

**那么HTTP数据传输过程中，这个对称加密表现在哪呢？**

对称加密的密钥（叫“会话密钥”或 session key）不是开发者手动配置的，也不是写在 Nginx 里的。它是在每次 TLS 握手时，由客户端（浏览器）和服务器（Nginx）自动协商生成的。这个密钥只用于当前连接，连接断开后就丢弃（支持前向保密）。Nginx 只负责参与这个协商过程，并用这个密钥加密/解密后续的 HTTP 数据。

场景说明：当访问 [https://example.com](https://example.com)：

1. TLS 握手阶段（前 1~2 个网络包）：
    1. 浏览器和 Nginx 协商加密套件（比如 TLS_AES_128_GCM_SHA256）
    2. 通过 ECDHE 密钥交换（现代主流）或 RSA，双方各自独立计算出同一个随机密钥 → 这就是 对称会话密钥（session key）
    3. 这个密钥从未在网络上传输！而是通过数学方法各自算出来。
2. 应用数据阶段（握手完成后）：
    1. 所有 HTTP 请求（GET /login）和响应（HTML 内容）
        1. → 都被 用这个 session key + AES-GCM 算法加密。
        2. → 然后通过 TCP 发送。
3. Nginx 收到密文后，用本地保存的 session key 解密，得到原始 HTTP 请求。
4. 同理，Nginx 返回的网页也用同一个 key 加密后再发回。

所以：对称加密体现在“所有实际传输的 HTTP 数据”上，而密钥是临时协商的。

**会话密钥（Session Key）长什么样？**

它是一个随机生成的二进制数据，长度取决于加密套件：

+ AES-128 → 128 位（16 字节）。
+ AES-256 → 256 位（32 字节）。

例如（十六进制表示）：

```plain
a1b2c3d4e5f67890123456789abcdef0
```

这个是TLS 库（如 OpenSSL）自动处理。

**Nginx 配置里与对称加密相关设置：**

不是配“密钥”的方式，而是选择支持哪些对称加密算法（叫“加密套件” Cipher Suites）。

例如在 Nginx 中：

```nginx
ssl_ciphers ECDHE+AESGCM:DHE+AESGCM:ECDHE+CHACHA20;
```

这行的意思是：

优先使用 ECDHE 密钥交换 + AES-GCM 对称加密，或者 ChaCha20（另一种对称加密算法）。

## 3、nginx中配置HTTPS证书
CA 证书是由受信任的“证书颁发机构”（CA）签发的数字证书，用于证明一个公钥确实属于某个网站、个人或组织。

一个典型的服务器证书（由 CA 签发）包含以下关键信息：

| 字段 | 说明 |
| --- | --- |
| 公钥 | 服务器的公钥（用于加密或验证签名） |
| 域名 | 如www.example.com，必须匹配用户访问的域名 |
| 颁发者 | 签发该证书的 CA 名称（如 "Let's Encrypt"、"DigiCert"） |
| 有效期 | 证书生效和过期时间（通常 90 天 ~ 1 年） |
| 数字签名 | CA 用自己的私钥对该证书内容进行的签名 |


之前我们的nginx证书，是直接使用的自签证书：

```nginx
openssl req -x509 -nodes -days 365 \
  -newkey rsa:2048 \
  -keyout selfsigned.key \
  -out selfsigned.crt
```

这种证书还是会导致访问的时候表现出不安全，其次，当本地git设置了ssl验证的时候，会导致我git服务器无法直接clone，需要临时将ssl验证关闭，下面就直接使用腾讯云提供的免费自签证书：

申请完成之后需要来进行替换，按照下面的步骤进行：

**①、获取证书文件**

从腾讯云SSL证书控制台下载证书，通常会得到：

    - handn.fun.crt（证书文件）。
    - handn.fun.key（私钥文件）。
    - 可能还有chain.crt（中间证书）。

**②、上传证书到服务器**

```bash
# 上传整个目录到用户目录
scp -r handn.fun_nginx zjh@111.230.115.143:/home/zjh/

# 登录服务器
ssh zjh@111.230.115.143

# 创建目标目录
sudo mkdir -p /etc/nginx/ssl/handn.fun

# 移动所有文件（注意：如果handn.fun_nginx是一个目录，则使用下面的命令）
sudo mv /home/zjh/handn.fun_nginx/* /etc/nginx/ssl/handn.fun/

# 设置权限
sudo chmod 600 /etc/nginx/ssl/handn.fun/handn.fun.key
sudo chmod 644 /etc/nginx/ssl/handn.fun/*.crt /etc/nginx/ssl/handn.fun/*.pem

# 删除上传的临时目录
rm -rf /home/zjh/handn.fun_nginx
```

**③、配置Nginx使用新证书**

```nginx
nginx
server {
  listen 443 ssl;
  server_name handn.fun www.handn.fun;

  # 使用腾讯云签发的证书
  ssl_certificate /etc/nginx/ssl/handn.fun/handn.fun.crt;
  ssl_certificate_key /etc/nginx/ssl/handn.fun/handn.fun.key;
  
  # 如果证书是链式证书，需要包含中间证书
  # ssl_certificate /etc/nginx/ssl/handn.fun/fullchain.crt;
  
  # 其余配置保持不变...
}
```

然后重启nginx：

```bash
docker exec nginx-https nginx -s reload
```

	但是发现无法重启，这是因为我们将证书是放在宿主机上，docker上的nginx无法访问，因此这个时候需要停止nginx，然后加上这个目录：

```nginx
# 确保证书目录存在并复制证书到正确位置
sudo mkdir -p ~/nginx/ssl/handn.fun
sudo cp /etc/nginx/ssl/handn.fun/* ~/nginx/ssl/handn.fun/
```

```bash
# 启动容器（注意：使用完整的镜像名称）
docker run -d \
  --name nginx-https \
  --restart unless-stopped \
  --network docker-data_gitlab-network \
  --network jenkins-network \
  -p 80:80 \
  -p 443:443 \
  -v ~/nginx/conf.d:/etc/nginx/conf.d:ro \
  -v ~/nginx/ssl:/etc/nginx/ssl:ro \
  -v /home/zjh/project:/home/zjh/project:ro \
  nginx:alpine
```




