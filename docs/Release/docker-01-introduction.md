---
group:
  title: Docker
order: 1
title: Docker介绍

nav:
  title: 发布部署
  order: 6
---

## 介绍

Docker 是一个开源的容器化平台，旨在简化应用程序的开发、部署和运行。它允许开发者将应用及其所有依赖（如代码、运行时、系统工具、库和配置文件）打包到一个轻量级、可移植的“容器”中，从而实现“一次构建，随处运行”（Build Once, Run Anywhere）的理念。

**核心概念：**

1. 镜像：镜像是一个只读模板，包含运行应用程序所需的所有内容（操作系统、代码、依赖等）。你可以把它理解为容器的“蓝图”。镜像可以通过 Dockerfile 构建。
2. 容器：容器是镜像的运行实例。当你启动一个镜像时，Docker 会创建一个隔离的运行环境——即容器。多个容器可以同时运行在同一个主机上，彼此隔离。
3. Dockerfile：一个文本文件，包含一系列指令，用于自动构建镜像。例如指定基础镜像、复制文件、安装依赖、设置环境变量、定义启动命令等。
4. Docker Hub/Registry：Docker Hub 是官方提供的公共镜像仓库，用户可以从中拉取或推送镜像。你也可以搭建私有的镜像仓库。
5. Docker Engine：Docker 的核心组件，负责构建、运行和管理容器。它包括一个守护进程、REST API 和 CLI。

## Docker 和虚拟机的差别

Docker（容器技术）和虚拟机是两种不同的“资源隔离”方案，其根本区别在于架构层级和虚拟化程度。我们可以用一个生动的比喻来理解：

- 虚拟机好比在一栋大楼里，建了好几套独立的公寓。每套公寓（虚拟机）都有自己独立的厨房、卫生间、墙壁（完整的操作系统），互不干扰，但占用空间大，建造和启动慢。
- Docker 容器好比在同一套公寓里，用轻质隔断分出的多个单间。所有单间（容器）共享大楼的水电主干和公寓的厨房卫生间（宿主机的内核和核心资源），但每个单间有自己的进程空间、网络和文件系统，隔离性稍弱但非常轻便高效。

下面是详细的对比表格：

| 特性       | Docker (容器)                                                                                   | 虚拟机                                                                                   |
| ---------- | ----------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------- |
| 核心架构   | 操作系统级虚拟化                                                                                | 硬件级虚拟化                                                                             |
| 虚拟化对象 | 虚拟化的是操作系统内核，所有容器共享宿主机内核。                                                | 虚拟化的是完整的硬件层，每个 VM 都有虚拟的 CPU、内存、磁盘等。                           |
| 宿主机要求 | 必须与宿主机操作系统内核相同（如 Linux 容器跑在 Linux 内核上）。Windows 容器需要 Windows 内核。 | 可运行与宿主机完全不同的操作系统（如在 Mac 上跑 Linux VM，在 Windows 上跑 Windows VM）。 |
| Guest OS   | 不需要完整的 Guest OS，只需包含应用及其依赖（二进制文件、库）。                                 | 需要完整的 Guest OS（如完整的 Ubuntu、CentOS 系统镜像）。                                |
| 镜像大小   | 非常小（通常从 MB 到几百 MB），只包含应用层。                                                   | 非常大（通常从 GB 到几十 GB），包含整个操作系统。                                        |
| 启动速度   | 极快（秒级），相当于启动一个进程。                                                              | 慢（分钟级），相当于启动一台完整的电脑。                                                 |
| 性能损耗   | 极低，接近原生性能，直接调用宿主机内核。                                                        | 较高，由于硬件虚拟化和完整的 OS 开销，通常有 5%-15%的性能损失。                          |
| 资源占用   | 低，多个容器可共享资源，利用率高。                                                              | 高，每个 VM 都需要独占分配的资源，存在浪费。                                             |
| 隔离性     | 进程级隔离，通过 Namespace 和 Cgroups 实现。安全性较弱（共享内核是潜在风险点）。                | 完全隔离，虚拟机之间如同物理机之间。安全性强。                                           |
| 部署与迁移 | 极简，镜像构建和分发非常快速，天生适合 CI/CD 和微服务。                                         | 较重，镜像迁移和克隆速度慢。                                                             |
| 典型代表   | Docker, Containerd, Podman (Kubernetes 的底层运行时)                                            | VMware, VirtualBox, Hyper-V, KVM                                                         |

**如何选择？**

**使用 Docker 容器的场景：**

1. 微服务架构：每个服务打包成一个容器，独立部署、扩展。
2. CI/CD 流水线：快速构建、测试、部署应用。
3. 高密度部署：在单台服务器上运行数百个隔离的应用实例，最大化资源利用率。
4. 云原生应用：与 Kubernetes 等编排工具无缝集成。
5. 需要快速启动和弹性伸缩的场景。

**使用虚拟机的场景：**

1. 运行不同内核的操作系统：例如在 Linux 服务器上运行 Windows 应用。
2. 需要完全隔离和安全性的场景：如多租户环境、安全审计要求高的系统。
3. 遗留系统或需要完整 OS 功能的场景：应用依赖特定 OS 的完整功能或内核模块。
4. 对硬件进行完全模拟和控制的场景。
