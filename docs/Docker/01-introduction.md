---
title: Docker介绍
order: 1
nav:
  title: Docker
  order: 1
---

## 介绍

Docker是一个开源的容器化平台，旨在简化应用程序的开发、部署和运行。它允许开发者将应用及其所有依赖（如代码、运行时、系统工具、库和配置文件）打包到一个轻量级、可移植的“容器”中，从而实现“一次构建，随处运行”（Build Once, Run Anywhere）的理念。

**核心概念：**

1. 镜像：镜像是一个只读模板，包含运行应用程序所需的所有内容（操作系统、代码、依赖等）。你可以把它理解为容器的“蓝图”。镜像可以通过Dockerfile构建。
2. 容器：容器是镜像的运行实例。当你启动一个镜像时，Docker会创建一个隔离的运行环境——即容器。多个容器可以同时运行在同一个主机上，彼此隔离。
3. Dockerfile：一个文本文件，包含一系列指令，用于自动构建镜像。例如指定基础镜像、复制文件、安装依赖、设置环境变量、定义启动命令等。
4. Docker Hub/Registry：Docker Hub是官方提供的公共镜像仓库，用户可以从中拉取或推送镜像。你也可以搭建私有的镜像仓库。
5. Docker Engine：Docker的核心组件，负责构建、运行和管理容器。它包括一个守护进程、REST API和CLI。

## Docker和虚拟机的差别
Docker（容器技术）和虚拟机是两种不同的“资源隔离”方案，其根本区别在于架构层级和虚拟化程度。我们可以用一个生动的比喻来理解：

+ 虚拟机好比在一栋大楼里，建了好几套独立的公寓。每套公寓（虚拟机）都有自己独立的厨房、卫生间、墙壁（完整的操作系统），互不干扰，但占用空间大，建造和启动慢。
+ Docker容器好比在同一套公寓里，用轻质隔断分出的多个单间。所有单间（容器）共享大楼的水电主干和公寓的厨房卫生间（宿主机的内核和核心资源），但每个单间有自己的进程空间、网络和文件系统，隔离性稍弱但非常轻便高效。

下面是详细的对比表格：

| 特性 | Docker (容器) | 虚拟机 |
| --- | --- | --- |
| 核心架构 | 操作系统级虚拟化 | 硬件级虚拟化 |
| 虚拟化对象 | 虚拟化的是操作系统内核，所有容器共享宿主机内核。 | 虚拟化的是完整的硬件层，每个VM都有虚拟的CPU、内存、磁盘等。 |
| 宿主机要求 | 必须与宿主机操作系统内核相同（如Linux容器跑在Linux内核上）。Windows容器需要Windows内核。 | 可运行与宿主机完全不同的操作系统（如在Mac上跑Linux VM，在Windows上跑Windows VM）。 |
| Guest OS | 不需要完整的Guest OS，只需包含应用及其依赖（二进制文件、库）。 | 需要完整的Guest OS（如完整的Ubuntu、CentOS系统镜像）。 |
| 镜像大小 | 非常小（通常从MB到几百MB），只包含应用层。 | 非常大（通常从GB到几十GB），包含整个操作系统。 |
| 启动速度 | 极快（秒级），相当于启动一个进程。 | 慢（分钟级），相当于启动一台完整的电脑。 |
| 性能损耗 | 极低，接近原生性能，直接调用宿主机内核。 | 较高，由于硬件虚拟化和完整的OS开销，通常有5%-15%的性能损失。 |
| 资源占用 | 低，多个容器可共享资源，利用率高。 | 高，每个VM都需要独占分配的资源，存在浪费。 |
| 隔离性 | 进程级隔离，通过Namespace和Cgroups实现。安全性较弱（共享内核是潜在风险点）。 | 完全隔离，虚拟机之间如同物理机之间。安全性强。 |
| 部署与迁移 | 极简，镜像构建和分发非常快速，天生适合CI/CD和微服务。 | 较重，镜像迁移和克隆速度慢。 |
| 典型代表 | Docker, Containerd, Podman (Kubernetes的底层运行时) | VMware, VirtualBox, Hyper-V, KVM |


**如何选择？**

**使用Docker容器的场景：**

1. 微服务架构：每个服务打包成一个容器，独立部署、扩展。
2. CI/CD流水线：快速构建、测试、部署应用。
3. 高密度部署：在单台服务器上运行数百个隔离的应用实例，最大化资源利用率。
4. 云原生应用：与Kubernetes等编排工具无缝集成。
5. 需要快速启动和弹性伸缩的场景。

**使用虚拟机的场景：**

1. 运行不同内核的操作系统：例如在Linux服务器上运行Windows应用。
2. 需要完全隔离和安全性的场景：如多租户环境、安全审计要求高的系统。
3. 遗留系统或需要完整OS功能的场景：应用依赖特定OS的完整功能或内核模块。
4. 对硬件进行完全模拟和控制的场景。
